package org.icgc.dcc.release.job.index.core;

import static org.assertj.core.api.Assertions.assertThat;
import static org.icgc.dcc.release.job.index.core.IndexJob.resolveIndexName;
import static org.icgc.dcc.release.job.index.factory.TransportClientFactory.newTransportClient;

import java.io.File;
import java.util.Map;

import lombok.SneakyThrows;
import lombok.val;
import lombok.extern.slf4j.Slf4j;

import org.apache.commons.io.FileUtils;
import org.elasticsearch.client.Client;
import org.elasticsearch.index.query.FilterBuilders;
import org.icgc.dcc.release.core.job.FileType;
import org.icgc.dcc.release.job.index.config.IndexProperties;
import org.icgc.dcc.release.job.index.model.DocumentType;
import org.icgc.dcc.release.test.job.AbstractJobTest;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import com.google.common.collect.ImmutableList;

@Slf4j
public class IndexJobTest extends AbstractJobTest {

  private static final String ES_URI = "es://localhost:9300";

  /**
   * Class under test.
   */
  IndexJob job;
  Client esClient;
  String index;

  @Override
  @Before
  public void setUp() {
    super.setUp();
    val properties = new IndexProperties()
        .setEsUri(ES_URI)
        .setOutputDir(new File(workingDir, "output").getAbsolutePath());

    this.job = new IndexJob(properties);
    this.index = resolveIndexName(RELEASE_VERSION);
    this.esClient = newTransportClient(ES_URI);
  }

  @After
  public void tearDown() {
    esClient.close();
  }

  @Test
  public void testExecute() {
    given(new File(TEST_FIXTURES_DIR));
    job.execute(createJobContext(job.getType(), ImmutableList.of("BRCA-UK")));

    verifyMutations();
    verifyRelease();
    verifyDonors();
  }

  private void verifyMutations() {
    verifyMutationsOutput();
    val hits = esClient.prepareSearch(index)
        .setTypes(DocumentType.MUTATION_CENTRIC_TYPE.getName())
        .execute()
        .actionGet();
    for (val hit : hits.getHits()) {
      val source = hit.getSource();
      verifyMutationCentric(source);
    }
  }

  private void verifyMutationsOutput() {
    val mutationCentric = produces(FileType.MUTATION_CENTRIC_INDEX);
    log.info("mutation-centric ouput {}", mutationCentric);
  }

  private static void verifyMutationCentric(Map<String, Object> source) {
    assertThat(source.get("ssm_occurrence")).isNotNull();
    assertThat(source.get("transcript")).isNotNull();
    assertThat(source.get("platform")).isNotNull();
  }

  private void verifyRelease() {
    val release = esClient.prepareSearch(index)
        .setTypes(DocumentType.RELEASE_TYPE.getName())
        .execute()
        .actionGet()
        .getHits()
        .getTotalHits();
    assertThat(release).isEqualTo(1L);
  }

  private void verifyDonors() {
    // verifyDonor();
    verifyDonorCentric();
  }

  private void verifyDonorCentric() {
    // FIXME: resolve type
    // FIXME: Finish thorough testing that verifies structure
    val donorsWithProjectCount = esClient
        .prepareSearch(index)
        .setTypes("donor-centric")
        .execute()
        .actionGet()
        .getHits()
        .getTotalHits();
    assertThat(donorsWithProjectCount).isEqualTo(2L);
  }

  @SuppressWarnings("unused")
  private void verifyDonor() {
    // FIXME: resolve type
    val donorsWithProjectCount = esClient
        .prepareSearch(index)
        .setTypes("donor")
        .setPostFilter(FilterBuilders.existsFilter("project"))
        .execute()
        .actionGet()
        .getHits()
        .getTotalHits();
    assertThat(donorsWithProjectCount).isEqualTo(2L);
  }

  @SneakyThrows
  private static void cleanOutputFiles() {
    // FIXME: Implement proper cleanup of files generated by the IndexJob
    val indexerDir = new File("indexer");
    if (indexerDir.exists()) {
      log.debug("Deleting directory: {}", indexerDir.getAbsolutePath());
      FileUtils.deleteDirectory(indexerDir);
    }
  }

}
